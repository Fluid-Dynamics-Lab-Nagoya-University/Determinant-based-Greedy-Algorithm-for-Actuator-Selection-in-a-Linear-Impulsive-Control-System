%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%F_act_dg_over1.m ver.240621%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [obj_select,index_select]=F_act_dg_over1(W,p,obj_select_under,index_select_under)
    %準備
    r=size(W,2);%今回考えるモードの数．
    index_select=zeros(p,1);%選択した点の番号を格納する列ベクトル．選択した順に上から格納される．
    index_select(1:r,1)=index_select_under;
    obj_select=zeros(p,1);%選択した点の目的関数を格納する列ベクトル．選択した順に上から格納される．
    obj_select(1:r,1)=obj_select_under;
    Ws=zeros(p,r);%Wから抽出した行列Ws．ループごとに配列の大きさが変わらないように，最初に定義しておく．
    Ws(1:r,:)=W(index_select_under,:);
    WAWI=inv(Ws(1:r,:)'*Ws(1:r,:));%inv(Wk'*Wk)．r×rの行列．inv(Wk'*Wk)はループごとに大きさは変わらない．最初にinv(Wr'*Wr)を入れる．
    %アクチュエータの選択
    for k=r+1:p%kはアクチュエータ番号
        %目的関数の計算
        obj=sum((W*WAWI).*conj(W),2);%目的関数の値から構成される列ベクトル（w_iに関する目的関数の値は，i行目の要素となる．)ここでは，WAWIはinv(W_{k-1}'*W_{k-1})．
        obj=abs(obj);%数学的にはobjの要素は実数となる（はずだ）が，数値計算上では僅かに虚部をもってしまうため，絶対値を取る．
        obj(index_select(1:k-1,1),1)=-Inf;%既に選択した要素を再度選択しないようにマイナス無限大を入力．ループごとにobjが計算し直されるので，毎回マイナス無限大を入力する必要がある．
        %目的関数が最大となる要素を探して記録
        [obj_max,index_obj_max]=max(obj);%最大値が複数存在する場合は，番号の若いほうが選択される．
        index_select(k,1)=index_obj_max;
        obj_select(k,1)=obj_max;
        %次のループのためにWsを更新
        Ws(k,:)=W(index_obj_max,:);
        %次のループのためにWAWIを更新
        denominator=1+Ws(k,:)*WAWI*Ws(k,:)';%この時点では，まだWAWIはinv(W_{k-1}'*W_{k-1})．
        WAWI=WAWI*(eye(r)-Ws(k,:)'*Ws(k,:)*WAWI/denominator);%ここで，WAWIはinv(W_k'*Wk)になる．
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%